문제 접근 방법:
1. 완전 탐색(Brute Force) 방식으로 접근
2. 모든 가능한 위치와 모든 가능한 돗자리 크기를 시도
3. 가장 큰 돗자리부터 시도하여 최적의 해를 찾음

사용할 알고리즘:
1. 정렬 알고리즘: mats 리스트를 내림차순으로 정렬
2. 완전 탐색: 모든 위치에서 모든 크기의 돗자리를 시도
3. 2차원 배열 탐색: park 배열의 각 위치를 순회

시간/공간 복잡도 분석:
1. 시간 복잡도:
   - mats 정렬: O(n log n), n은 mats의 길이
   - park 배열 순회: O(R * C), R은 행 수, C는 열 수
   - 각 위치에서 돗자리 크기 확인: O(k * k), k는 돗자리 크기
   - 전체 시간 복잡도: O(n log n + R * C * k * k)

2. 공간 복잡도:
   - 입력 배열 저장: O(R * C)
   - 추가 공간: O(1)
   - 전체 공간 복잡도: O(R * C)

최적화 포인트:
1. mats를 내림차순으로 정렬하여 큰 돗자리부터 시도
2. 빈 공간("-1")이 아닌 위치는 건너뛰기
3. 돗자리 크기가 공원 크기를 벗어나는 경우 즉시 건너뛰기
4. 한 위치에서 돗자리를 놓을 수 없으면 다음 위치로 이동

고려사항:
1. 입력값 검증
   - mats와 park가 비어있는 경우
   - park 배열의 크기가 유효한지
   - 각 위치의 값이 유효한지

2. 경계 조건
   - 돗자리 크기가 공원 크기를 벗어나는 경우
   - 돗자리를 놓을 수 있는 공간이 없는 경우

3. 예외 처리
   - 잘못된 입력 형식
   - 범위를 벗어나는 인덱스 접근
   - 돗자리를 놓을 수 없는 경우 