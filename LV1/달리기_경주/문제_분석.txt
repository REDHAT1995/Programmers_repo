# 문제 분석

## 1. 문제 접근 방법
1. 데이터 구조 파악
   - players: 선수들의 현재 순위를 나타내는 리스트
   - callings: 추월이 발생한 순서대로 선수 이름이 담긴 리스트
   - 각 선수의 현재 순위를 빠르게 찾을 수 있는 구조 필요

2. 효율적인 순위 변경
   - 선수 이름으로 현재 순위를 O(1)에 찾을 수 있어야 함
   - 순위 변경 시 최소한의 연산으로 처리 필요
   - 해시맵(딕셔너리)을 사용하여 이름-순위 매핑 관리

3. 순위 업데이트 프로세스
   - 호출된 선수의 현재 순위 찾기
   - 해당 선수와 바로 앞 선수의 위치 교환
   - 두 선수의 순위 정보 업데이트

## 2. 시간 복잡도 분석
- 초기 해시맵 생성: O(n), n = players 길이
- 각 호출당 처리 시간: O(1)
- 전체 호출 처리: O(m), m = callings 길이
- 전체 시간 복잡도: O(n + m)

## 3. 공간 복잡도 분석
- 선수 이름-순위 매핑: O(n)
- 순위-선수 이름 매핑: O(n)
- 전체 공간 복잡도: O(n)

## 4. 최적화 포인트
1. 해시맵 활용
   - 선수 이름으로 순위 조회: O(1)
   - 순위로 선수 이름 조회: O(1)
   - 양방향 매핑으로 빠른 접근 가능

2. 리스트 연산 최소화
   - 불필요한 리스트 복사 제거
   - 제자리 업데이트로 메모리 효율성 향상
   - 순위 변경 시 필요한 부분만 수정

3. 데이터 일관성 유지
   - 두 해시맵의 동기화 관리
   - 순위 변경 시 양쪽 모두 업데이트
   - 잘못된 상태 방지

## 5. 고려사항
1. 입력값 제한
   - players 길이: 5 ~ 50,000
   - callings 길이: 2 ~ 1,000,000
   - 대용량 데이터 처리 가능해야 함

2. 메모리 사용
   - 추가 공간 사용은 O(n)으로 제한
   - 불필요한 임시 리스트 생성 피하기
   - 효율적인 메모리 관리 필요

3. 예외 처리
   - 1등 선수는 호출되지 않음이 보장됨
   - 모든 입력이 유효함이 보장됨
   - 별도의 예외 처리 불필요 