# 구현 알고리즘 설명

## 1. 데이터 처리 단계

### 1.1 컬럼 인덱스 매핑
```python
column_map = {
    "code": 0,      # 코드 번호
    "date": 1,      # 제조일
    "maximum": 2,    # 최대 수량
    "remain": 3     # 현재 수량
}
```
- 문자열로 된 컬럼명을 리스트 인덱스로 매핑
- O(1) 시간에 컬럼 접근 가능
- 코드 가독성과 유지보수성 향상

### 1.2 데이터 필터링
```python
filtered_data = [
    item for item in data
    if item[column_map[ext]] < val_ext
]
```
- ext 매개변수에 해당하는 컬럼의 값이 val_ext보다 작은 데이터만 추출
- 리스트 컴프리헨션 사용으로 코드 간결화
- O(n) 시간 복잡도

### 1.3 데이터 정렬
```python
sorted_data = sorted(filtered_data, key=lambda x: x[column_map[sort_by]])
```
- sort_by 매개변수에 해당하는 컬럼을 기준으로 오름차순 정렬
- lambda 함수로 정렬 키 지정
- O(n log n) 시간 복잡도

## 2. 구현 세부 사항

### 2.1 입력값 처리
- data: 2차원 리스트 형태로 입력
- ext: 컬럼명을 나타내는 문자열
- val_ext: 필터링 기준값
- sort_by: 정렬 기준 컬럼명

### 2.2 데이터 검증
- 문제 조건에 따라 별도의 입력값 검증은 생략
- 입력값이 항상 유효하다고 가정
- 결과가 항상 1개 이상 존재함이 보장됨

### 2.3 결과 반환
- 필터링 및 정렬된 2차원 리스트 반환
- 원본 데이터의 구조 유지
- 각 행의 모든 컬럼 정보 포함

## 3. 최적화 기법

### 3.1 메모리 최적화
- 리스트 컴프리헨션 사용으로 중간 리스트 생성 최소화
- 불필요한 복사 연산 제거
- 메모리 사용량 최적화

### 3.2 성능 최적화
- 딕셔너리로 O(1) 시간에 컬럼 접근
- 내장 정렬 함수 사용으로 안정적인 성능
- 단일 순회로 필터링 수행

### 3.3 코드 최적화
- 간결하고 명확한 코드 구조
- 재사용 가능한 컴포넌트 설계
- 유지보수가 용이한 구조

## 4. 테스트 케이스 설명

### 4.1 기본 테스트 케이스
```python
data = [[1, 20300104, 100, 80], [2, 20300804, 847, 37], [3, 20300401, 10, 8]]
ext = "date"
val_ext = 20300501
sort_by = "remain"
결과: [[3, 20300401, 10, 8], [1, 20300104, 100, 80]]
```
- 제조일이 20300501 이전인 데이터 필터링
- 현재 수량 기준 오름차순 정렬

### 4.2 코드 번호 기준 테스트
```python
ext = "code"
val_ext = 3
sort_by = "date"
결과: [[1, 20300104, 100, 80], [2, 20300804, 847, 37]]
```
- 코드 번호가 3 미만인 데이터 필터링
- 제조일 기준 오름차순 정렬

### 4.3 최대 수량 기준 테스트
```python
ext = "maximum"
val_ext = 500
sort_by = "code"
결과: [[1, 20300104, 100, 80], [3, 20300401, 10, 8]]
```
- 최대 수량이 500 미만인 데이터 필터링
- 코드 번호 기준 오름차순 정렬

### 4.4 현재 수량 기준 테스트
```python
ext = "remain"
val_ext = 50
sort_by = "maximum"
결과: [[3, 20300401, 10, 8], [2, 20300804, 847, 37]]
```
- 현재 수량이 50 미만인 데이터 필터링
- 최대 수량 기준 오름차순 정렬 